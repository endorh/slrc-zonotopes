from __future__ import annotations

import itertools
from fractions import Fraction
from typing import Literal
from math import isqrt

import numpy as np

def ceil_isqrt(n: int) -> int:
    """
    Computes the ceiling of the square root of a non-negative integer.
    """
    floor_isqrt = isqrt(n)
    if floor_isqrt*floor_isqrt == n:
        return floor_isqrt
    return floor_isqrt + 1

def determinant(matrix: np.ndarray[tuple[int, int], int]) -> int:
    """
    Determinant of an integer 3x3 matrix, using exact unbound integer arithmetic.

    Using Laplace expansion for clarity.

    See `slrz.rational.linalg.determinant` for a Gaussian elimination implementation.
    """
    n = matrix.shape[1]
    if n == 1:
        return matrix[0, 0]
    det = 0
    for i in range(n):
        det += ((-1)**i) * matrix[0, i] * determinant(np.delete(matrix[1:], i, axis=1))
    return det

def volume_vector(generators: np.ndarray[tuple[Literal[3], Literal[4]], int]) -> tuple[int, int, int, int]:
    """
    Computes the signed volume vector of a 4-LRZ, obtained as the determinants
    of the four 3×3 minors of the matrix of generators of Z.
    """
    assert generators.shape == (3, 4), "Invalid shape"

    # Unrolled for clarity:
    return (
        + determinant(generators[:, (   1, 2, 3)]),
        - determinant(generators[:, (0,    2, 3)]),
        + determinant(generators[:, (0, 1,    3)]),
        - determinant(generators[:, (0, 1, 2   )]),
    )

def lr_3_zonotope_inequalities(
    generators: np.ndarray[tuple[Literal[3], Literal[4]], int]
) -> tuple[
    np.ndarray[tuple[Literal[12], Literal[3]], int],
    np.ndarray[tuple[Literal[12]], int]
]:
    # Preallocate matrix of facet normals, filled with zeros
    A = np.zeros((12, 3), dtype=int)

    # For each pair of generators, compute their cross product,
    # and fill them into the next available rows of A
    r = 0
    for i in range(4):
        for j in range(i + 1, 4):
            g_i = generators[:, i]
            g_j = generators[:, j]
            cross = np.cross(g_i, g_j)

            # Ensure no two generators are linearly dependent
            assert np.any(cross != 0), f"Generators {g_i} and {g_j} are proportional"

            A[r, :] = cross
            A[r+1, :] = -cross

            r += 2

    b = np.maximum(0, A @ generators).sum(axis=1)
    return A, b


def centrally_symmetric_lr_3_zonotope_inequalities(
    generators: np.ndarray[tuple[Literal[3], Literal[4]], int]
) -> tuple[
    np.ndarray[tuple[Literal[12], Literal[3]], int],
    np.ndarray[tuple[Literal[12]], int]
]:
    """
    Derives the facet description of a 3-LR zonotope from its generators,
    given as a 3×4 matrix, where each column represents a generator.

    The returned inequalities describe a centrally symmetric embedding
    of the zonotope given by integer matrices.
    """
    # Preallocate matrix of facet normals, filled with zeroes
    A = np.zeros((12, 3), dtype=int)

    # Initialize caret position for writing rows into A
    r = 0

    # For each pair of generators, compute their cross product,
    # and fill them into the next available row of A
    for i in range(4):
        for j in range(i+1, 4):
            g_i = generators[:, i]
            g_j = generators[:, j]
            cross = np.cross(g_i, g_j)

            # Ensure no two generators are linearly dependent
            assert np.any(cross), f"Generators {g_i} and {g_j} are proportional"

            # Add the two opposing faces with the normal defined by g_i and g_j
            A[r, :] = cross
            A[r+1, :] = -cross

            # Increase caret position by two rows
            r += 2

    # Compute b as sum of abs(dot product with each generator)
    b = np.abs(A @ generators).sum(axis=1)

    # The computation of `b` accounts for each generator and its opposite,
    # between every face and its opposite.
    # Hence, {Ax <= b} is in fact the zonotope generated by the double of
    # all generators, and we simply take {2Ax <= b} to compensate.
    A_doubled = A * 2

    return A_doubled, b


class DyadicVoxelType:
    """
    The type of a dyadic voxel, consisting of:
    - The depth of the voxel within the infinite dyadic tree
      (the sides of the voxel are of length 2**-depth)
    - The offset of the voxel within the unit cube in 2**-depth units
    """

    # The root dyadic voxel type (a full unit cube)
    root: DyadicVoxelType

    def __init__(self, depth: int, offset: tuple[int, int, int]):
        self.depth = depth
        self.offset = tuple(offset)

    @property
    def side_denominator(self):
        """
        The denominator of the length of the sides of this voxel, which is
        a dyadic number of the form 2^(-depth).
        """
        return 2**self.depth

    def subdivide(self) -> list[DyadicVoxelType]:
        """
        Subdivide this voxel type into 2ᵈ sub-voxels.
        """
        subtypes = []
        for dx in (0, 1):
            for dy in (0, 1):
                for dz in (0, 1):
                    subtypes.append(DyadicVoxelType(
                        self.depth + 1, (
                            self.offset[0]*2 + dx,
                            self.offset[1]*2 + dy,
                            self.offset[2]*2 + dz)))
        return subtypes


# Initialize class constant after class
DyadicVoxelType.root = DyadicVoxelType(0, (0, 0, 0))


class ArrangedDyadicNode:
    """
    A non-leaf node in an arranged dyadic tree.

    Contains exactly 2ᵈ sub-nodes, indexed in ascending reverse lexicographic order (ZYX).
    """
    def __init__(self, children: list[ArrangedDyadicNode | ArrangedDyadicVoxel]):
        self.children = tuple(children)

    def vertices(self, type: DyadicVoxelType = DyadicVoxelType.root) -> list[tuple[Fraction, Fraction, Fraction]]:
        """
        Compute the list of all vertices of the children of this node when assigned to the given type.
        """
        return [
            vertex
            for child, subtype in zip(self.children, type.subdivide())
            for vertex in child.vertices(subtype)]

    def depth(self) -> int:
        """
        The depth of the dyadic subtree under this node.
        """
        return max(child.depth() for child in self.children) + 1


class ArrangedDyadicVoxel:
    """
    A voxel covering a portion of a VoxelizedFundamentalDomain.

    Represents the equivalence class of points with fractional
    parts in [displacement_numerator/side_denominator, displacement_numerator + 1/side_denominator]

    This representative is associated with a lattice translation that
    makes it contained within a certain convex body to bound its covering radius.
    """
    def __init__(self, lattice_translation: np.ndarray[tuple[Literal[3]], int]):
        self.lattice_translation = lattice_translation

    def vertices(self, type: DyadicVoxelType = DyadicVoxelType.root) -> list[tuple[Fraction, Fraction, Fraction]]:
        """
        Return a list of vertex positions of this voxel in geometric space.
        """
        vertices = []
        for vertex_offset in itertools.product((0, 1), repeat=3):
            vertices.append(tuple(
                Fraction(
                    self.lattice_translation[i] * type.side_denominator
                    + type.offset[i] + vertex_offset[i],
                    type.side_denominator
                ) - Fraction(1, 2)
                for i in range(3)
            ))
        return vertices

    def depth(self) -> int:
        """
        The depth of the dyadic subtree under this node.
        """
        return 0

class DyadicFundamentalDomain:
    """
    Represents a dyadic fundamental domain, a subtree of the infinite dyadic tree
    labeled with lattice offsets in Z^3.

    The method check_is_contained_in_zonotope checks whether all voxels are contained
    in a rational polytope given by its facet description.
    """
    def __init__(self, root: ArrangedDyadicNode | ArrangedDyadicVoxel):
        self.root = root

    def depth(self) -> int:
        """
        The depth of the dyadic fundamental domain.
        """
        return self.root.depth()

    def is_depth_zero(self):
        """
        Check whether the depth of this dyadic fundamental domain is zero.
        """
        return isinstance(self.root, ArrangedDyadicVoxel)

    def is_contained_in_polytope(
        self,
        facet_normals: np.ndarray[tuple[int, int], int],
        facet_levels: np.ndarray[tuple[int], int],
    ):
        """
        Check whether all voxels of this dyadic fundamental domain are contained within the
        polytope defined by the given facet normals and levels:
        P = {x ∈ ℝ³: Ax <= b}
        :param facet_normals: The A matrix above.
        :param facet_levels:  The b vector above.
        """
        vertices = set(self.root.vertices(DyadicVoxelType.root))
        for vertex in vertices:
            # Explanation:
            #   vertex = (v_x/2ᵈˣ, v_y/2ᵈʸ, v_z/2ᵈᶻ)
            #   vertex_denominator = 2ᵈ = lcm(2ᵈˣ, 2ᵈʸ, 2ᵈᶻ) = max(2ᵈˣ, 2ᵈʸ, 2ᵈᶻ)
            #   vertex_upscaled = 2ᵈ vertex = (2^(d-dx) v_x, 2^(d-dy) v_y, 2^(d-dz) v_z)
            #   P_upscaled = 2ᵈ P = {x ∈ ℝ³: A(2^(-d) x) <= b} = {x ∈ ℝ³: Ax <= 2ᵈ b}
            #   facet_levels_upscaled = 2ᵈ b = 2ᵈ facet_levels
            #
            #   Av <= b ⇐⇒ A(2ᵈ v) <= 2ᵈ b
            #   facet_normals @ vertex <= facet_levels ⇐⇒ facet_normals @ vertex_upscaled <= facet_levels_upscaled
            vertex_denominator = max(*tuple(coord.denominator for coord in vertex))
            vertex_upscaled = np.array(tuple(
                coord.numerator * (vertex_denominator // coord.denominator)
                for coord in vertex
            ), dtype=int)
            facet_levels_upscaled = facet_levels * vertex_denominator

            if np.any(facet_normals @ vertex_upscaled > facet_levels_upscaled):
                return False
        return True


class SLRCCertificate:
    def __init__(
        self,
        volume_vector: tuple[int, int, int, int],
        generators: np.ndarray[tuple[Literal[3], Literal[4]], int],
        fundamental_domain: DyadicFundamentalDomain,
        cov_radius: Fraction,
        epsilon: Fraction
    ):
        self.volume_vector = volume_vector
        self.generators = generators
        self.fundamental_domain = fundamental_domain
        self.cov_radius = cov_radius
        self.epsilon = epsilon

    def is_valid(self):
        # Check that the stored volume vector matches the stored generators
        if not tuple(volume_vector(self.generators)) == self.volume_vector:
            print(f"  invalid volume vector: {tuple(volume_vector(self.generators))} != {self.volume_vector}")
            return False

        # Check that the stored epsilon is a valid choice
        if not self.is_epsilon_valid():
            print(f"  invalid epsilon")
            return False

        # Compute centrally symmetric facet description of the zonotope
        facet_normals, facet_levels = centrally_symmetric_lr_3_zonotope_inequalities(self.generators)

        # Scale zonotope by (covering radius + epsilon)
        r = self.cov_radius + self.epsilon
        scaled_facet_normals = facet_normals * r.denominator
        scaled_facet_levels = facet_levels * r.numerator

        # Check that the stored fundamental domain is contained in the scaled polytope
        if not self.fundamental_domain.is_contained_in_polytope(scaled_facet_normals, scaled_facet_levels):
            print(f"  fundamental domain not contained in scaled polytope")
            return False
        return True

    def is_epsilon_valid(self):
        """
        Ensures the epsilon value is strictly smaller than the proven bound
        from Proposition 2.8.
        :return: True if the epsilon value is valid, False otherwise.
        """
        if self.epsilon <= 0:
            return True

        A, b = lr_3_zonotope_inequalities(self.generators)

        four_rows_denominator_bound = 1
        for four_row_indices in itertools.combinations(range(len(A)), 4):
            # For every combination of four rows of (A|b)
            A_sub = A[four_row_indices, :]
            b_sub = b[four_row_indices,]

            # Compute the determinant of (A_sub | -b_sub)
            det = determinant(np.concatenate((A_sub, -b_sub[:, np.newaxis]), axis=1))
            four_rows_denominator_bound = max(four_rows_denominator_bound, abs(det))

        if self.epsilon < Fraction(1, self.cov_radius.denominator * four_rows_denominator_bound):
            return True

        return False
